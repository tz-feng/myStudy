一、为什么用HashMap？
1.HashMap是一个散列桶（数组和链表），它存储的内容是键值对(key-value)映射
2.HashMap采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改
3.HashMap是非synchronized，所以HashMap很快
4.HashMap可以接受null键和值，而Hashtable则不能（原因就是equlas()方法需要对象，因为HashMap是后出的API经过处理才可以）

二、HashMap的工作原理是什么？
HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。

以下是具体的put过程（JDK1.8版）
1、对Key求Hash值，然后再计算下标
2、如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中）
3、如果碰撞了，以链表的方式链接到后面
4、如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表
5、如果节点已经存在就替换旧值
6、如果桶满了(容量16*加载因子0.75)，就需要 resize（扩容2倍后重排）

以下是具体get过程(考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？)
1.HashMap会使用键对象的hashcode找到bucket位置
2.找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。

碰撞也称为hash冲突：
两个不同的key，通过hashcode()方法计算出一样的值。于是他们两的存储位置会发生冲突。

发生冲突的存储方式：
1.7是链表，头插法，我猜测头插的理由是：新加入的值应该比旧的值更有可能用到，定位到数组节点时，在头部能更快找到。不论头插还是尾插，都需要把整条链表遍历一遍，确定key在不在链表里。1.7版本中，产生哈希冲突时，遍历一条链表查找对象，时间复杂度时O(n),随着链表越来越长，查找的时间越来越大。为了提高这个冲突的查找效率，1.8在链表长度超过8时，把链表转变成红黑树，大大减少查找时间。为了防止链表或红黑树巨大，需要了解扩容这个概念。

扩容机制与负载因子？
初始容器容量是16，负载因子默认0.75，最大容量2的30次幂。意思就是当前容量到达12(16*0.75=12)的时候，会触发扩容机制。数据结构就是为了省时间省空间，扩容机制和负载因子的设定肯定也是为了效率。

为什么负载因子是0.75？
因为如果负载因子过大，那么就意味发生冲突的概率就会越大。如果负载因子过小，那么会造成大量的空间被浪费。

三、有什么方法可以减少碰撞？
1.使用扰动函数，原理是让返回的hashcode尽量不相同，只要hashcode不同，就不会发生冲突，这样子链表的规模也会小，就不会频繁调用equals方法，这样可以提高hashmap的性能。

四、HashMap中hash函数怎么是是实现的?
JDK1.8的源码
static final int hash(Object key) {
 	if (key == null){
 		return 0;
 	}
 	int h;
 	h=key.hashCode()；返回散列值也就是hashcode
 	// ^ ：按位异或
 	// >>>:无符号右移，忽略符号位，空位都以0补齐
 	//其中n是数组的长度，即Map的数组部分初始化长度
 	return (n-1)&(h ^ (h >>> 16));
}
1.判断key是否为空，如果为空则返回0，否则计算数组下标。
2.获取key的hashcode，将其转化为32位的二进制。将得到的二进制数与它本身往后移动16位的二进制数进行异或（即高16位与0000 0000 0000 0000异或的结果 + 高16位与低16位异或的结果）
3.再将数组的初始长度n减去1，转变为二进制，然后将其与第二步中的结果相与，最终得到数组下标。

五、拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？
二叉查找树：
值为一，在创建二叉查找树时，如果比根节点小的数就放到左边，比根节点大的数放到右边。查找时通过判断大小沿着正确的方向查找下去，不用查找整棵树。

红黑树：
在每个节点加一个存储为表示节点的颜色，非红即黑。根节点中使黑色，如果节点时红色的，则它子节点一定是黑色（反之不一定）。每个叶子节点都是黑色的空节点。从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）

因为二叉查找树也有可能形成一条链表，例如每次插入的数都比原来小，或者比原来大。这样会使得查询速度非常的满，时间复杂度是O(n)。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题。但是它也是需要付出代价的，但是该代价比遍历线性链表要小，所以当长度大于8的时候会使用红黑树，如果长度过短，引入红黑树，反而会更慢。

六、HashMap与HashTable的区别
1.继承与实现
HashMap是继承自AbstractMap类，而HashTable是继承自Dictionary类。不过它们都同时实现了Map、Cloneable（可复制）、Serializable（可序列化）这三个接口。存储的内容是基于key-value的键值对映射，不能有重复的key，而且一个key只能映射一个value。HashSet底层就是基于HashMap实现的。

2.key-value
HashMap可以存放空值，如null-null，null-value，key-null，key-value
HashTable不可以存放空值，只能为key-value
注意：HashMap不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。因为如果存放的值是空值，返回的是null，无法判断是否存在。

3.扩容
HashMap:默认初始容量是16，严格要求是2的幂次方，每次扩容到原来的2倍
HashTable:默认初始容量是11，不要求是2的幂次方，每次扩容到原来的2倍+1

4.求索引
HashMap求索引：index=(n-1)&(h^(h>>>16))
HashTable求索引：index=（key.hashCode() & 0x7FFFFFFF）% table.length

5.线程安全性
HashMap线程不安全。
HashTable是线程安全的，它的一些方法加了synchronized。
所以HashMap的效率比HashTable高。

七、HashSet和HashMap的区别
1.HashSet实现的是Set接口，HashMap实现的是Map接口
2.HashSet仅仅存储对象，HashMap存储键值对
3.HashSet使用add()方法将元素存入set中，HashMap使用put()方法将元素放入map中
4.HashSet使用成员对象来计算hashcode值，HashMap使用键对象来计算hashcode值
5.HashMap比较块，因为是使用唯一的键来获取对象

八、了解一下LinkedHashMap
从Linked这个名字可以知道肯定和链表有关，它的数据结构附加了双向链表，弥补HashMap无序的缺点。

HashMap在存入的时候通过&计算索引，这个索引不是有序的，所以在遍历HashMap的时候，无法获得插入时的顺序。而LinkedHashMap把插入的节点用链表连接起来，通过链表来遍历，可以获得插入时的顺序。（在不知道这个东西的情况下，要我获取HashMap的插入顺序的话，我会开两个ArrayList或者LinkedList来记录顺序，并且一一对应key和value）。线程不安全。

九、了解一下HashSet
Map是映射，那就是key-value。Set是集合，无序不重复，存的只是key，不是两个对象组成的键值对key-value。底层数据结构是HashMap，它存的对象放在key里。线程不安全。

十、了解一下HashTree
底层数据结构是裸的红黑树，保证元素有序，没有比较器Comparator的情况按照key的自然排序，可自定义比较器。线程不安全。


