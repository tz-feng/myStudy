一、Java锁的种类
乐观锁/悲观锁
独享锁/共享锁
互斥锁/读写锁
可重入锁
公平锁/非公平锁
分段锁
偏向锁/轻量级锁/重量级锁
自旋锁

二、乐观锁/悲观锁
1、乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。

1.1、数据版本机制
1.1.1、实现数据版本一般有两种，第一种是使用版本号，第二种是使用时间戳。

1.1.1.1、版本号方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

1.1.1.2、如果是时间戳的话就比较之前和之后的时间是否一致。

1.2、CAS（Compare and Swap 比较并交换）操作
1.2.1、CAS（Compare and Swap 比较并交换），当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

1.2.2、CAS操作中包含三个操作数——需要读写的内存位置(V)、进行比较的预期原值(A)和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B，否则处理器不做任何操作。


2、悲观锁：每次去获取数据的时候都会认为别人会修改数据，所以每次拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。比如Java里面的同步原语synchronized关键字的实现就是悲观锁。悲观锁适合写操作非常多的场景。


3、乐观锁不会上锁，但是每次在修改数据前都会判断其他线程在这之前有没有对数据进行修改，一般会使用“数据版本机制”或“CAS操作”来实现。

三、独享锁/共享锁
1、独享锁：是指该锁只能被一个线程锁持有。（如：synchronized）

2、共享锁：是指该锁能被多个线程所持有。

3、对于ReentrantLock类而言，其是独享锁，但是对于ReadWriteLock类，其读锁是共享锁，写锁是独享锁。

4、读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。

5、独享锁与共享锁都是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。

四、互斥锁/读写锁
1、独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。

2、互斥锁在Java中的具体实现就是ReentrantLock。

3、读写锁在Java中的具体实现就是ReadWriteLock。

五、可重入锁
1、可重入锁：指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class）
synchronized void setA() throws Exception{
　　Thread.sleep(1000);
　　setB();
}

synchronized void setB() throws Exception{
　　Thread.sleep(1000);
}
上面的代码就是一个可重入锁的一个特点。如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。

2、优点：避免死锁。

六、公平锁/非公平锁
1、公平锁：是指多个线程按照申请锁的顺序来获取锁。

2、非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级倒置（优先级低的先获得锁）或者饥饿现象（有些线程一直获取不了锁）。

3、非公平锁的有点：吞吐量比公平锁大。

七、分段锁
1、分段锁：分段锁其实是一种锁的设计,并不是具体的一种锁。他能有效的提高在多线程情况下的速度。
例子：HashMap、HashTable与ConcurrentHashMap。
HashMap与HashTable的实现原理几乎是一样的。他们的区别就在于HashTable的键值对不能为null。而且HashTable是线程安全的。但是HashTable也为它的线程安全付出了代价，那就是并发慢。Map的结构都是由数组+链表+红黑树实现的（jdk1.8之后），HashTable的实现线程安全十分的简单粗暴，他直接将数组锁起来了。也就是说，如果当一个线程在访问数组时，其他的线程都只能等待，这就大大的降低了它的性能。而ConcurrentHashMap不一样，它使用的是分段锁。它是将数组分成好几段，然后再给这几段分别加上锁。如果数组长度是16，每段的长度为4，假设有2个线程，一个访问数据下标0，一个访问数据下标4，那么他们可以直接访问，不需要等一个完成了再访问。这样子大大的提升了线程并发的速度。

参考网址：https://www.jianshu.com/p/552df05d5a24

八、偏向锁/轻量级锁/重量级锁
1、这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。

1.1、偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。

1.2、轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。（轻量级锁也叫自旋锁）

1.3、重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。

锁的升级过程：（结合笔记JVM.md的markword的结构图一起看）
（1）首先，当一个对象刚开始被创建时，此时处于无锁状态。
（2）当对象被加上锁时，此时变为了偏向锁，此时把对象的markword的线程ID改为自己线程的ID。
（3）如果有多个线程来争用资源，此时，先撤销偏向锁，然后多个线程对锁进行争夺，由于每个线程都有自己的线程栈，每个线程栈里头存放着自己的Lock Record（LR），通过CAS，如果谁争夺到了，那么把对象的markword修改为对应线程的LR指针。其他的线程会一直进行CAS操作。
（4）当竞争加剧（有现成超过10次自旋，或者自旋线程数超过CPU核数的一半），升级为重量级锁（重量级锁是非常重要的，所以需要通过内核态进行申请）。升级为重量级锁后，线程就会进入重量级锁的队列中，轮到谁，谁就去用。

九、自旋锁
1、自旋锁：是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

十、AQS与CAS
1、AQS
1.1、Abstract Queued Synchronized 抽象队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch...

1.2、AQS维护了一个volatile语义(支持多线程下的可见性)的共享资源变量state和一个FIFO线程等待队列(多线程竞争state被阻塞时会进入此队列)。

1.2.1、state是一个int数据类型，其访问方式有3中：
getState()
setState(int newState)
compareAndSetState(int expect, int update)

1.3、AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。

1.4、不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：
isHeldExclusively():该线程是否正在独占资源。只有用到condition才需要去实现它。
tryAquire(int):独占方式。尝试获取资源，成功则返回true，失败则返回false。
tryRelease(int):独占方式。尝试释放资源，成功则返回true，失败则返回false。
tryAcquireShared(int):共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
tryReleaseShared(int):共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。


2、CAS
2.1、CAS（Compare and Swap 比较并交换）是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

2.2、CAS操作中包含三个操作数——需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值（B）。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B，否则处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值（在CAS的一些特殊情况下将仅返回CAS是否成功，而不提取当前值）。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可”。这其实和乐观锁的冲突检查+数据更新的原理是一样的。（俗话：先获取原来的值E，然后再计算结果V，再获取当前值N，比较E和N，如果相等，则更新值为V，反之不更新。）

3.CSA中会存在ABA问题。

3.1、什么是ABA问题？
ABA问题就是由于CSA是通过原值是否被修改来判断该数据是否已被其他线程访问，但是有可能出现虽然被修改了，但是修改后的值与原值一样，所以当其他线程在进行判断的时候会认为该数据没被其他线程访问。这就是ABA问题。

例子：
假设一个值为0，被A，B，C三个线程访问。A获取该值时为0，在A线程修改该值前，该值被B修改为3，然后又被C修改为0。所以当A在修改时，他会认为该数据没被其他线程修改过。

3.2、如何解决ABA问题？
解决方式很简单，只需要再加多一个版本号就可以了，就如同乐观锁的版本号机制一样。

CAS对应的底层实现是汇编指令的：lock compxchg
注意：compxchg是非原子性的

十一、锁消除lock eliminate
public void add（String str1，String str2）{
	StringBuffer sb = new StringBuffer()；
	sb.append(str1).append(str2);
}
我们都知道StringBuffer是线程安全的，因为它的关键方法都是被 synchronized修饰过的，但是看上面这段代码，我们会发现，sb这个引用只会在add方法中使用，不可被别的线程引用（因为sb是局部变量，栈私有），因此sb是不可能共享的资源，JVM会自动消除StringBuffer对象内部的锁。

十二、锁粗化
public void test() {
	StringBuffer sb = new StringBuffer()；
	int i=0;
	while (i<100) {
		sb.append(i);
		i++;
	}
}
JVM会检测到while里头的代码，如果这个代码代运行起来会非常麻烦，因为要上锁解锁100次，因此会对锁进行粗化，直接将锁加载while上，这就是锁的粗化。


参考网址：https://www.cnblogs.com/hustzzl/p/9343797.html
