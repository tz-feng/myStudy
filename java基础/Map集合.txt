一、Map集合介绍
1、Map（也称为字典、关联数组）是用于保存具有映射关系的数据，保存两组值，key和value，这两组值可以是任何应用类型的数据。

2、Map的key不允许重复（底层Map的keySet()返回的是key的Set集合，所以key不会重复），即Map中对象的任意两个key通过equals()方法得到的都是false。而Map的value值是可以重复的（Map的底层values()方法返回类型是Collection，可以存储重复元素），通过key总能找到唯一的value，Map中的key组成一个Set集合，所以可以通过keySet()方法返回所有key。Set底层也是通过Map实现的，只不过value都是null的Map来实现的。

二、HashMap
1、HashMap继承AbstractMap类。HashMap底层是数组和链表的结合体。底层是一个线性数组结构，数组中的每一项又是一个链表。HashMap是非同步的，线程不安全。保存的数据key和value都可以为unll。HashMap底层数组的长度是2^n，默认是16,负载因子为0.75，所以最大容量阈值threshold = (int)(capacity * loadFactor);16*0.75=12，当超过这个阈值的时候，开始扩容，即每次扩容增加一倍。

2、HashMap结构0 
JDK1.8 以前HashMap的实现是 数组+链表。
JDK1.8 开始HashMap的实现是 数组+链表+红黑树。

3、HashMap中有两个常量：
static final int TREEIFY_THRESHOLD = 8;
static final int UNTREEIFY_THRESHOLD = 6;
当链表中节点数量大于等于TREEIFY_THRESHOLD（8），那么链表就会转换成红黑树。
当链表中节点数量小于等于UNTREEIFY_THRESHOLD（6），那么红黑树就会转换成链表。

4、HashMap工作原理
4.1、我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组下标。

4.2、以下是具体的put过程（JDK1.8版）
1、对Key求Hash值，然后再计算下标
2、如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中）
3、如果碰撞了，以链表的方式链接到后面
4、如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表
5、如果节点已经存在就替换旧值
6、如果桶满了(容量16*加载因子0.75)，就需要 resize（扩容2倍后重排）

4.3、以下是具体get过程(考虑特殊情况如果两个键的hashcode相同，你如何获取值对象？)
1.HashMap会使用键对象的hashcode找到bucket位置
2.找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。

4.4、碰撞也称为hash冲突：
两个不同的key，通过hashcode()方法计算出一样的值。于是他们两的存储位置会发生冲突。

4.5、发生冲突的存储方式：
1.7是链表，头插法，我猜测头插的理由是：新加入的值应该比旧的值更有可能用到，定位到数组节点时，在头部能更快找到。不论头插还是尾插，都需要把整条链表遍历一遍，确定key在不在链表里。1.7版本中，产生哈希冲突时，遍历一条链表查找对象，时间复杂度时O(n),随着链表越来越长，查找的时间越来越大。为了提高这个冲突的查找效率，1.8在链表长度超过8时，把链表转变成红黑树，大大减少查找时间。为了防止链表或红黑树巨大，需要了解扩容这个概念。

4.6、扩容机制与负载因子？
初始容器容量是16，负载因子默认0.75，最大容量2的30次幂。意思就是当前容量到达12(16*0.75=12)的时候，会触发扩容机制。数据结构就是为了省时间省空间，扩容机制和负载因子的设定肯定也是为了效率。

4.7、为什么负载因子是0.75？
因为如果负载因子过大，那么就意味发生冲突的概率就会越大。如果负载因子过小，那么会造成大量的空间被浪费。

4.8、有什么方法可以减少碰撞？
使用扰动函数，原理是让返回的hashcode尽量不相同，只要hashcode不同，就不会发生冲突，这样子链表的规模也会小，就不会频繁调用equals方法，这样可以提高hashmap的性能。

4.9、HashMap中hash函数怎么是是实现的?
JDK1.8的源码
static final int hash(Object key) {
 	if (key == null){
 		return 0;
 	}
 	int h;
 	h=key.hashCode()；返回散列值也就是hashcode
 	// ^ ：按位异或
 	// >>>:无符号右移，忽略符号位，空位都以0补齐
 	//其中n是数组的长度，即Map的数组部分初始化长度
 	return (n-1)&(h ^ (h >>> 16));
}

4.9.1、判断key是否为空，如果为空则返回0，否则计算数组下标。

4.9.2、获取key的hashcode，将其转化为32位的二进制。将得到的二进制数与它本身往后移动16位的二进制数进行异或（即高16位与0000 0000 0000 0000异或的结果 + 高16位与低16位异或的结果）

4.9.3、再将数组的初始长度n减去1，转变为二进制，然后将其与第二步中的结果相与，最终得到数组下标。

4.10、拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？
二叉查找树：
值为一，在创建二叉查找树时，如果比根节点小的数就放到左边，比根节点大的数放到右边。查找时通过判断大小沿着正确的方向查找下去，不用查找整棵树。

红黑树：
在每个节点加一个存储为表示节点的颜色，非红即黑。根节点中使黑色，如果节点时红色的，则它子节点一定是黑色（反之不一定）。每个叶子节点都是黑色的空节点。从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）

因为二叉查找树也有可能形成一条链表，例如每次插入的数都比原来小，或者比原来大。这样会使得查询速度非常的满，时间复杂度是O(n)。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题。但是它也是需要付出代价的，但是该代价比遍历线性链表要小，所以当长度大于8的时候会使用红黑树，如果长度过短，引入红黑树，反而会更慢。

三、HashTable
1、HashTable继承的是Dictionary类，它的底层原理和结构与HashMap相似。但是HashTable是同步的，线性安全，而且存放的值不能为空。

2、HashTable工作原理

2.1、put方法的主要逻辑如下：
2.1.1、先获取synchronized锁。
2.1.2、put方法不允许null值，如果发现是null，则直接抛出异常。
2.1.3、计算key的哈希值和index
2.1.4、遍历对应位置的链表，如果发现已经存在相同的hash和key，则更新value，并返回旧值。
2.1.5、如果不存在相同的key的Entry节点，则调用addEntry方法增加节点。
2.1.6、addEntry方法中，如果需要则进行扩容，之后添加新节点到链表头部。

2.2、get方法的主要逻辑如下：
2.2.1、先获取synchronized锁。
2.2.2、计算key的哈希值和index。
2.2.3、在对应位置的链表中寻找具有相同hash和key的节点，返回节点的value。
2.2.4、如果遍历结束都没有找到节点，则返回null。

2.3、rehash扩容方法主要逻辑如下：
2.3.1、数组长度增加一倍（如果超过上限，则设置成上限值）。
2.3.2、更新哈希表的扩容门限值。
2.3.3、遍历旧表中的节点，计算在新表中的index，插入到对应位置链表的头部。

四、LinkedHashMap
1、LinkedHashMap继承的是HashMap类。key和value都允许为空，key重复会覆盖,value可以重复，有序的，LinkedHashMap是非线程安全的。LinkedHashMap底层是由数组和循环双向链表实现的。

五、TreeMap
1、底层数据结构是红黑树，保证元素有序，没有比较器Comparator的情况按照key的自然排序，可自定义比较器。线程不安全。







