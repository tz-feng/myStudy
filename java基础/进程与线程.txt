程序、进程和线程
程序：是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。

进程：是执行程序的一次执行过程，他是一个动态的概念，是系统资源分配的单位。一个进程可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。

线程：是进程的一个执行单元，cpu调度和执行的单位，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。

一个程序至少一个进程，一个进程至少一个线程。

线程与进程的区别
地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。
资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。
	一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

　　　　　进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。

执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
线程是处理器调度和执行的基本单位，进程是系统资源分配和调度的独立单位。
两者均可并发执行。

进程的特征：
1.动态性：进程的实质是进程实体的执行过程
2.并发性：多个进程实体在内存中，且能够在一段时间内同时运行。
3.独立性：进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单位
4.异步性：每个进程按各自独立的、不可预知的速度前进。

进程的三大基本状态
1.就绪状态：进程已分配到除cpu外的所有必要资源。
2.执行状态：已经获得cpu资源，其程序正在运行。
3.阻塞状态：正在执行的进程由于发生某事件使得进程无法继续执行。

线程的六种状态
1. New:初始状态，线程被创建，没有调用start（）
2. Runnable:运行状态，Java线程把操作系统中的就绪和运行两种状态统一称为“运行中”
3. Blocked:阻塞，线程进入等待状态，线程因为某种原因，放弃了CPU的使用权
阻塞的几种情况：
A. 等待阻塞：运行的线程执行了wait()，JVM会把当前线程放入等待队列
B. 同步阻塞：运行的线程在获取对象的同步锁时，如果该同步锁被其他线程占用了，JVM会把当前线程放入锁池中
C. 其他阻塞：运行的线程执行sleep(),join()或者发出IO请求时，JVM会把当前线程设置为阻塞状态，当sleep()执行完，join()线程终止，IO处理完毕线程再次恢复
4. Waiting:等待状态
5. timed_waiting:超时等待状态，超时以后自动返回
6. terminated:终止状态，当前线程执行完毕

线程的三种创建方式：
1.继承Thread类，重写run()方法，调用start()方法开启线程。(重点)
class A extends Thread{
	//重写run()方法
	@Override
    	public void run() {

        	}
}

public static void main(String[] args) {
	new A().start();
}

2.实现runnable接口，实现run()方法，执行线程需要丢入runnable接口实现类。(重点)
class A implements Runnable{
	//实现run()方法
	@Override
    	public void run() {

        	}
}

public static void main(String[] args) {
	new Thread(new A()).start();
}

3.实现callable接口，实现call()方法，创建执行服务，提交执行，关闭服务。(了解)
/**
 * callable的好处
 * 1.可以定义返回值
 * 2.可以抛出异常。
 */
class A implements Callable<V>{
	//实现run()方法
	@Override
    	public V call() throws Exception{

        	}
}
public static void main(String[] args) {
	//创建执行服务：
        	ExecutorService ser = Executors.newFixedThreadPool(3);

	//提交执行
        	Future<Boolean> r1 = ser.submit(new A());

	//关闭服务
        	ser.shutdownNow();
}

Lambda表达式
要求：目标是一个函数式接口（函数式接口：只有一个抽象方法的接口）。
用法：()->{}
例如：
interface A{
    void a();
}

public static void main(String[] args) {
	A a = ()->{};
}

1.如果方法中有参数时，可以去掉其参数类型。
2.如果只有一个参数时，可以去掉括号。
3.如果只有一句执行语句时，可以去掉大括号。

线程的停止
1.建议线程正常停止--->利用次数，不建议死循环
if(count<i) break;

2.建议使用标志位--->设置一个标志位
flag = true;
if(表达式) flag = false；

3.不要使用stop或者destroy等过时或者JDK不建议使用的方法

线程的休眠
Thread.sleep(long millis);	参数为整数，代表毫秒（ms）
用于倒计时，网络延时等。还可以放大问题的发生性。

线程的礼让
yield();		让当前进程从cup中出来，重新进入就绪状态与其他线程争抢时间片。
注意：礼让不一定会成功，因为当前线程出来后会继续跟其他的线程竞争，所以他有可能重新进入到cpu中去。

线程的强制执行
join()	该方法会让cpu中的线程出来，然后让该线程进入，而且其他线程只有在等他完成后才能再进入cpu。

线程的优先级
setPriority(int newPriority);		重新设置线程的优先级，数字越高，优先级越高。
注意：
1.线程的优先级一共分为1-10级，默认等级为5级。如果超出范围，则会报错。
2.优先级高不一定先执行，有可能出现优先级低的会在优先高的前面执行。优先级高不代表一定会先执行，只是被执行的概率会大于优先级低的。

守护线程
可以通过setDaemon(true)来开启守护线程。默认是false，表示是用户线程，正常的线程都是用户线程。Daemon属性需要在启动线程之前设置，不能在启动后设置。
JVM（java虚拟机）必须确保用户线程执行完毕，但不需要等待守护线程执行完毕。
例如：我们的程序在运行的过程中必须要等所有的用户线程都执行完了才会停止，如果我们在用户线程中加入一个死循环的守护线程，那么程序依然会在用户线程执行完毕后就停止，不会管守护线程是否还在执行。

线程同步
由于同一进程的多个线程共享同一存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可。
存在的问题：
1.一个线程持有锁时，会导致其他需要此锁的线程被挂起。
2.加锁和释放锁会导致较多的上下文切换和调度延时，引起性能问题
3.如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。

死锁
多个线程各自占有一些共享资源，并且相互等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题。

产生死锁的四个必要条件：
1.互斥条件：一个资源每次只能被一个进程使用
2.请求与保持条件：一个进程因请求资源而阻塞时，对以获得的资源保持不放。
3.不剥夺条件：进程已获得的资源，在未使用完之前不能强行剥夺。
4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

解决方法：破环其中的一个或多个条件即可避免死锁发生。

synchronized 和 Lock 有什么区别？
1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；
6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。

java多线程面试题网址：https://www.jianshu.com/p/3e88a5fe75f0

